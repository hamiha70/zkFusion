// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "./interfaces/ILimitOrderProtocol.sol";
import "./CommitmentFactory.sol";
import "./BidCommitment.sol";

// Groth16 Verifier interface (auto-generated by Circom)
interface IVerifier {
    function verifyProof(
        uint[2] memory _pA,
        uint[2][2] memory _pB,
        uint[2] memory _pC,
        uint[6] memory _pubSignals
    ) external view returns (bool);
}

/**
 * @title zkFusionExecutor
 * @dev Main contract for executing zkFusion auctions with ZK proof verification
 * @notice Updated for 1inch LOP v4 compatibility
 */
contract zkFusionExecutor {
    ILimitOrderProtocol public immutable lop;
    IVerifier public immutable verifier;
    CommitmentFactory public immutable factory;
    
    event ProofVerified(
        address indexed commitmentContract,
        uint256 totalFill,
        uint256 weightedAvgPrice
    );
    
    event AuctionExecuted(
        address indexed commitmentContract,
        bytes32 indexed orderHash,
        uint256 makingAmount,
        uint256 takingAmount,
        address[] winners
    );
    
    constructor(
        address _lop,
        address _verifier,
        address _factory
    ) {
        lop = ILimitOrderProtocol(_lop);
        verifier = IVerifier(_verifier);
        factory = CommitmentFactory(_factory);
    }
    
    // Helper functions to work with Address type (which is uint256 in 1inch)
    function _addressFromUint(Address addr) internal pure returns (address) {
        return address(uint160(Address.unwrap(addr)));
    }
    
    function _addressToUint(address addr) internal pure returns (Address) {
        return Address.wrap(uint256(uint160(addr)));
    }
    
    function _takerTraitsFromUint(uint256 value) internal pure returns (TakerTraits) {
        return TakerTraits.wrap(value);
    }
    
    /**
     * @dev Execute auction with ZK proof verification (mock signature version)
     * @param proof The Groth16 proof components
     * @param publicInputs The public inputs to the ZK circuit
     * @param winners Array of winning bidder addresses
     * @param commitmentContractAddress Address of the commitment contract used
     * @param order The 1inch LOP order to fill
     * @param orderSignature The maker's signature for the order (will be split into r,vs)
     */
    function executeWithProof(
        uint[8] calldata proof,
        uint[6] calldata publicInputs,
        address[] calldata winners,
        address commitmentContractAddress,
        ILimitOrderProtocol.Order calldata order,
        bytes calldata orderSignature
    ) external {
        // 1. Verify the ZK proof
        _verifyProof(proof, publicInputs);
        
        // 2. Verify commitment contract and winners
        _verifyCommitments(publicInputs, winners, commitmentContractAddress);
        
        // 3. Execute the fill on 1inch LOP
        _executeFill(publicInputs, commitmentContractAddress, winners, order, orderSignature);
    }
    
    function _verifyProof(uint[8] calldata proof, uint[6] calldata publicInputs) internal {
        uint[2] memory pA = [proof[0], proof[1]];
        uint[2][2] memory pB = [[proof[2], proof[3]], [proof[4], proof[5]]];
        uint[2] memory pC = [proof[6], proof[7]];
        
        require(verifier.verifyProof(pA, pB, pC, publicInputs), "Invalid ZK proof");
    }
    
    function _verifyCommitments(
        uint[6] calldata publicInputs,
        address[] calldata winners,
        address commitmentContractAddress
    ) internal {
        require(factory.isValidCommitmentContract(commitmentContractAddress), "Invalid commitment contract");
        require(uint160(commitmentContractAddress) == publicInputs[5], "Commitment contract address mismatch");
        
        BidCommitment commitmentContract = BidCommitment(commitmentContractAddress);
        
        for (uint256 i = 0; i < winners.length && i < 4; i++) {
            if (winners[i] != address(0)) {
                bytes32 expectedCommitment = commitmentContract.getCommitment(winners[i]);
                require(expectedCommitment != bytes32(0), "Winner has no commitment");
                require(expectedCommitment == bytes32(publicInputs[i]), "Commitment mismatch for winner");
            }
        }
    }
    
    function _executeFill(
        uint[8] calldata publicInputs,
        address commitmentContractAddress,
        address[] calldata winners,
        ILimitOrderProtocol.Order calldata order,
        bytes calldata orderSignature
    ) internal {
        uint256 totalFill = publicInputs[4];
        
        emit ProofVerified(commitmentContractAddress, totalFill, publicInputs[5]);
        
        require(totalFill > 0, "No fill amount");
        require(totalFill <= order.makingAmount, "Fill exceeds order amount");
        
        // For mock implementation, we'll use fillContractOrder with the signature bytes
        // In production, you'd split the signature into r,vs components for fillOrder
        (uint256 makingAmount, uint256 takingAmount, bytes32 orderHash) = lop.fillContractOrder(
            order,
            orderSignature,
            totalFill,
            _takerTraitsFromUint(0) // Simple taker traits for mock
        );
        
        emit AuctionExecuted(commitmentContractAddress, orderHash, makingAmount, takingAmount, winners);
    }
    
    /**
     * @dev Helper function to create an order with proper Address types
     */
    function createOrder(
        uint256 salt,
        address maker,
        address receiver,
        address makerAsset,
        address takerAsset,
        uint256 makingAmount,
        uint256 takingAmount,
        uint256 makerTraits
    ) external pure returns (ILimitOrderProtocol.Order memory) {
        return ILimitOrderProtocol.Order({
            salt: salt,
            maker: _addressToUint(maker),
            receiver: _addressToUint(receiver),
            makerAsset: _addressToUint(makerAsset),
            takerAsset: _addressToUint(takerAsset),
            makingAmount: makingAmount,
            takingAmount: takingAmount,
            makerTraits: MakerTraits.wrap(makerTraits)
        });
    }
} 
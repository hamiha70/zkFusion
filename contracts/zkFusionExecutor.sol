// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "./interfaces/ILimitOrderProtocol.sol";
import "./BidCommitment.sol";
import "./CommitmentFactory.sol";

// Groth16 Verifier interface (auto-generated by Circom)
interface IVerifier {
    function verifyProof(
        uint[2] memory _pA,
        uint[2][2] memory _pB,
        uint[2] memory _pC,
        uint[8] memory _pubSignals
    ) external view returns (bool);
}

/**
 * @title zkFusionExecutor
 * @dev Main contract for executing zkFusion auctions with ZK proof verification
 * @notice Verifies ZK proofs of auction correctness and triggers 1inch LOP fills
 */
contract zkFusionExecutor {
    
    IVerifier public immutable verifier;
    CommitmentFactory public immutable factory;
    ILimitOrderProtocol public immutable lop;
    
    event AuctionExecuted(
        address indexed commitmentContract,
        address[] winners,
        uint256 totalFill,
        uint256 weightedAvgPrice
    );
    
    event ProofVerified(
        address indexed commitmentContract,
        uint256 totalFill,
        uint256 weightedAvgPrice
    );
    
    /**
     * @dev Constructor
     * @param _verifier Address of the Groth16 verifier contract
     * @param _factory Address of the CommitmentFactory
     * @param _lop Address of the 1inch Limit Order Protocol
     */
    constructor(
        address _verifier,
        address _factory,
        address _lop
    ) {
        verifier = IVerifier(_verifier);
        factory = CommitmentFactory(_factory);
        lop = ILimitOrderProtocol(_lop);
    }
    
    /**
     * @dev Executes an auction with ZK proof verification
     * @param proof The Groth16 proof components
     * @param publicInputs The public inputs to the ZK circuit
     * @param winners Array of winning bidder addresses
     * @param commitmentContractAddress Address of the commitment contract used
     * @param order The 1inch LOP order to fill
     * @param orderSignature The maker's signature for the order
     */
    function executeWithProof(
        uint[8] calldata proof, // [pA[0], pA[1], pB[0][0], pB[0][1], pB[1][0], pB[1][1], pC[0], pC[1]]
        uint[8] calldata publicInputs,
        address[] calldata winners,
        address commitmentContractAddress,
        ILimitOrderProtocol.Order calldata order,
        bytes calldata orderSignature
    ) external {
        // 1. Verify the ZK proof
        uint[2] memory pA = [proof[0], proof[1]];
        uint[2][2] memory pB = [[proof[2], proof[3]], [proof[4], proof[5]]];
        uint[2] memory pC = [proof[6], proof[7]];
        
        require(
            verifier.verifyProof(pA, pB, pC, publicInputs),
            "Invalid ZK proof"
        );
        
        // 2. Verify the commitment contract was created by our trusted factory
        require(
            factory.isValidCommitmentContract(commitmentContractAddress),
            "Invalid commitment contract"
        );
        
        // 3. Verify the commitment contract address matches the one in public inputs
        // Assuming the contract address is encoded as the last public input
        require(
            uint160(commitmentContractAddress) == publicInputs[7],
            "Commitment contract address mismatch"
        );
        
        // 4. Verify that each winner's commitment matches what's stored on-chain
        BidCommitment commitmentContract = BidCommitment(commitmentContractAddress);
        
        for (uint256 i = 0; i < winners.length && i < 4; i++) { // Max 4 winners for N=4 circuit
            if (winners[i] != address(0)) {
                bytes32 expectedCommitment = commitmentContract.getCommitment(winners[i]);
                require(expectedCommitment != bytes32(0), "Winner has no commitment");
                require(
                    expectedCommitment == bytes32(publicInputs[i]),
                    "Commitment mismatch for winner"
                );
            }
        }
        
        // 5. Extract auction results from public inputs
        uint256 totalFill = publicInputs[4]; // Assuming totalFill is at index 4
        uint256 weightedAvgPrice = publicInputs[5]; // Assuming weightedAvgPrice is at index 5
        
        emit ProofVerified(commitmentContractAddress, totalFill, weightedAvgPrice);
        
        // 6. Execute the fill on 1inch LOP
        require(totalFill > 0, "No fill amount");
        require(totalFill <= order.makingAmount, "Fill exceeds order amount");
        
        // Call LOP to fill the order
        (uint256 actualMaking, uint256 actualTaking) = lop.fillOrder(
            order,
            orderSignature,
            totalFill,
            0, // No minimum threshold for this demo
            order.receiver != address(0) ? order.receiver : order.maker
        );
        
        require(actualTaking > 0, "Fill failed");
        
        emit AuctionExecuted(
            commitmentContractAddress,
            winners,
            actualTaking,
            weightedAvgPrice
        );
    }
    
    /**
     * @dev Verifies a proof without executing (for testing)
     * @param proof The Groth16 proof components
     * @param publicInputs The public inputs to the ZK circuit
     * @return bool True if the proof is valid
     */
    function verifyProofOnly(
        uint[8] calldata proof,
        uint[8] calldata publicInputs
    ) external view returns (bool) {
        uint[2] memory pA = [proof[0], proof[1]];
        uint[2][2] memory pB = [[proof[2], proof[3]], [proof[4], proof[5]]];
        uint[2] memory pC = [proof[6], proof[7]];
        
        return verifier.verifyProof(pA, pB, pC, publicInputs);
    }
    
    /**
     * @dev Returns the expected public input format for documentation
     * @return string Description of public input format
     */
    function getPublicInputFormat() external pure returns (string memory) {
        return "publicInputs[0-3]: winner commitments, [4]: totalFill, [5]: weightedAvgPrice, [6]: makerAsk, [7]: commitmentContractAddress";
    }
} 
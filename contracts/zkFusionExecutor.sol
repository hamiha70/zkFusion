// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "./interfaces/ILimitOrderProtocol.sol";
import "./CommitmentFactory.sol";
import "./BidCommitment.sol";

// Fixed circuit size for zkFusion hackathon
// For production, deploy separate contracts for different N values
uint8 constant N_MAX_BIDS = 8;

// Groth16 Verifier interface (auto-generated by Circom)
interface IVerifier {
    function verifyProof(
        uint[2] memory _pA,
        uint[2][2] memory _pB,
        uint[2] memory _pC,
        uint[3] memory _pubSignals  // Updated: now expects 3 outputs (totalFill, totalValue, numWinners)
    ) external view returns (bool);
}

/**
 * @title zkFusionExecutor
 * @dev Main contract for executing zkFusion auctions with ZK proof verification
 * @notice Updated for 1inch LOP v4 compatibility
 */
contract zkFusionExecutor {
    ILimitOrderProtocol public immutable lop;
    IVerifier public immutable verifier;  // Made public for ZkFusionGetter access
    CommitmentFactory public immutable factory;  // Made public for ZkFusionGetter access
    
    event ProofVerified(
        address indexed commitmentContract,
        uint256 totalFill,
        uint256 weightedAvgPrice
    );
    
    event AuctionExecuted(
        address indexed commitmentContract,
        bytes32 indexed orderHash,
        uint256 makingAmount,
        uint256 takingAmount,
        address[] winners
    );
    
    constructor(
        address _lop,
        address _verifier,
        address _factory
    ) {
        lop = ILimitOrderProtocol(_lop);
        verifier = IVerifier(_verifier);
        factory = CommitmentFactory(_factory);
    }
    
    // Helper functions to work with Address type (which is uint256 in 1inch)
    function _addressFromUint(Address addr) internal pure returns (address) {
        return address(uint160(Address.unwrap(addr)));
    }
    
    function _addressToUint(address addr) internal pure returns (Address) {
        return Address.wrap(uint256(uint160(addr)));
    }
    
    function _takerTraitsFromUint(uint256 value) internal pure returns (TakerTraits) {
        return TakerTraits.wrap(value);
    }
    
    /**
     * @dev Execute a zkFusion auction with ZK proof verification
     * @param proof The Groth16 proof (8 field elements: pA, pB, pC)
     * @param publicOutputs The public outputs from ZK circuit [totalFill, totalValue, numWinners]
     * @param originalWinnerBits 8-element array indicating which bidders won
     * @param commitmentContractAddress Address of the commitment contract for this auction
     * @param order The 1inch Limit Order Protocol order to fill
     * @param orderSignature Signature for the order
     */
    function executeWithProof(
        uint[8] calldata proof,
        uint[3] calldata publicOutputs,
        uint[8] calldata originalWinnerBits,
        address commitmentContractAddress,
        ILimitOrderProtocol.Order calldata order,
        bytes calldata orderSignature
    ) external {
        // 1. Verify the ZK proof
        _verifyProof(proof, publicOutputs);
        
        // 2. Verify commitment contract and winner bits
        _verifyCommitments(publicOutputs, originalWinnerBits, commitmentContractAddress);
        
        // 3. Execute the fill on 1inch LOP
        _executeFill(publicOutputs, commitmentContractAddress, originalWinnerBits, order, orderSignature);
    }
    
    function _verifyProof(uint[8] calldata proof, uint[3] calldata publicOutputs) internal {
        uint[2] memory pA = [proof[0], proof[1]];
        uint[2][2] memory pB = [[proof[2], proof[3]], [proof[4], proof[5]]];
        uint[2] memory pC = [proof[6], proof[7]];
        
        require(verifier.verifyProof(pA, pB, pC, publicOutputs), "Invalid ZK proof");
    }
    
    function _verifyCommitments(
        uint[3] calldata publicOutputs,
        uint[8] calldata originalWinnerBits,
        address commitmentContractAddress
    ) internal {
        require(factory.isValidCommitmentContract(commitmentContractAddress), "Invalid commitment contract");
        
        // Extract values from public outputs
        // publicOutputs = [totalFill, totalValue, numWinners]
        uint256 zkTotalFill = publicOutputs[0];
        uint256 zkTotalValue = publicOutputs[1];
        uint256 zkNumWinners = publicOutputs[2];
        
        // Validate basic constraints
        require(zkTotalFill > 0, "Invalid total fill");
        require(zkTotalValue > 0, "Invalid total value");
        require(zkNumWinners <= N_MAX_BIDS, "Too many winners");
        
        // Count actual winners from originalWinnerBits
        uint256 actualWinners = 0;
        for (uint8 i = 0; i < N_MAX_BIDS; i++) {
            if (originalWinnerBits[i] == 1) {
                actualWinners++;
            }
        }
        require(actualWinners == zkNumWinners, "Winner count mismatch");
        
        // Note: The ZK circuit validates that originalWinnerBits correctly represents
        // the auction winners and that the commitments match the revealed bids
    }
    
    function _executeFill(
        uint[3] calldata publicOutputs,
        address commitmentContractAddress,
        uint[8] calldata originalWinnerBits,
        ILimitOrderProtocol.Order calldata order,
        bytes calldata orderSignature
    ) internal {
        // Extract values from public outputs
        // publicOutputs = [totalFill, totalValue, numWinners]
        uint256 totalFill = publicOutputs[0];
        uint256 totalValue = publicOutputs[1];
        uint256 numWinners = publicOutputs[2];
        
        emit ProofVerified(commitmentContractAddress, totalFill, totalValue);
        
        require(totalFill > 0, "No fill amount");
        require(totalFill <= order.makingAmount, "Fill exceeds order amount");
        
        // Convert winner bits to addresses for event emission
        address[] memory winnerAddresses = new address[](numWinners);
        uint256 winnerIndex = 0;
        
        BidCommitment commitmentContract = BidCommitment(commitmentContractAddress);
        for (uint8 i = 0; i < N_MAX_BIDS && winnerIndex < numWinners; i++) {
            if (originalWinnerBits[i] == 1) {
                // This bidder won - get their address from commitment contract
                // Note: This requires the commitment contract to track bidder addresses
                // For now, we'll use a placeholder since BidCommitment needs refactoring
                winnerAddresses[winnerIndex] = address(uint160(i + 1)); // Placeholder
                winnerIndex++;
            }
        }
        
        // Execute the fill on 1inch LOP
        TakerTraits takerTraits = _takerTraitsFromUint(0);
        lop.fillContractOrder(order, orderSignature, totalFill, takerTraits);
        
        emit AuctionExecuted(
            commitmentContractAddress,
            bytes32(0), // Placeholder for orderHash
            totalFill,   // makingAmount
            totalValue,  // takingAmount
            winnerAddresses
        );
    }
    
    /**
     * @dev Helper function to create an order with proper Address types
     */
    function createOrder(
        uint256 salt,
        address maker,
        address receiver,
        address makerAsset,
        address takerAsset,
        uint256 makingAmount,
        uint256 takingAmount,
        uint256 makerTraits
    ) external pure returns (ILimitOrderProtocol.Order memory) {
        return ILimitOrderProtocol.Order({
            salt: salt,
            maker: _addressToUint(maker),
            receiver: _addressToUint(receiver),
            makerAsset: _addressToUint(makerAsset),
            takerAsset: _addressToUint(takerAsset),
            makingAmount: makingAmount,
            takingAmount: takingAmount,
            makerTraits: MakerTraits.wrap(makerTraits)
        });
    }
    
    /**
     * @dev View function to verify ZK auction proof and return total value
     * @notice Used by ZkFusionGetter for 1inch LOP integration
     * @param proof The Groth16 proof components [a, b, c]
     * @param publicSignals Public signals [totalFill, totalValue, numWinners]
     * @param originalWinnerBits The original winner bits (for future validation)
     * @param commitmentContractAddress Address of the commitment contract
     * @return totalValue The verified total taking amount
     */
    function verifyAuctionProof(
        uint[8] calldata proof,
        uint[3] calldata publicSignals,
        uint[8] calldata originalWinnerBits,
        address commitmentContractAddress
    ) external view returns (uint256 totalValue) {
        // 1. Verify commitment contract is valid
        require(factory.isValidCommitmentContract(commitmentContractAddress), "Invalid commitment contract");
        
        // 2. Verify the ZK proof
        uint[2] memory pA = [proof[0], proof[1]];
        uint[2][2] memory pB = [[proof[2], proof[3]], [proof[4], proof[5]]];
        uint[2] memory pC = [proof[6], proof[7]];
        
        require(verifier.verifyProof(pA, pB, pC, publicSignals), "Invalid ZK proof");
        
        // 3. Extract and validate total value
        totalValue = publicSignals[1]; // totalValue is the second element
        require(totalValue > 0, "Invalid total value");
        
        // 4. Additional validations can be added here
        // - Verify originalWinnerBits consistency (future enhancement)
        // - Verify commitment consistency (future enhancement)
        
        return totalValue;
    }
} 
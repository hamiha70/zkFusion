// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "./interfaces/ILimitOrderProtocol.sol";
import "./BidCommitment.sol";
import "./CommitmentFactory.sol";

// Groth16 Verifier interface (auto-generated by Circom)
interface IVerifier {
    function verifyProof(
        uint[2] memory _pA,
        uint[2][2] memory _pB,
        uint[2] memory _pC,
        uint[8] memory _pubSignals
    ) external view returns (bool);
}

/**
 * @title zkFusionExecutor
 * @dev Main contract for executing zkFusion auctions with ZK proof verification
 * @notice Verifies ZK proofs of auction correctness and triggers 1inch LOP fills
 */
contract zkFusionExecutor {
    
    IVerifier public immutable verifier;
    CommitmentFactory public immutable factory;
    ILimitOrderProtocol public immutable lop;
    
    event AuctionExecuted(
        address indexed commitmentContract,
        address[] winners,
        uint256 totalFill,
        uint256 weightedAvgPrice
    );
    
    event ProofVerified(
        address indexed commitmentContract,
        uint256 totalFill,
        uint256 weightedAvgPrice
    );
    
    /**
     * @dev Constructor
     * @param _verifier Address of the Groth16 verifier contract
     * @param _factory Address of the CommitmentFactory
     * @param _lop Address of the 1inch Limit Order Protocol
     */
    constructor(
        address _verifier,
        address _factory,
        address _lop
    ) {
        verifier = IVerifier(_verifier);
        factory = CommitmentFactory(_factory);
        lop = ILimitOrderProtocol(_lop);
    }
    
    /**
     * @dev Executes an auction with ZK proof verification
     * @param proof The Groth16 proof components
     * @param publicInputs The public inputs to the ZK circuit
     * @param winners Array of winning bidder addresses
     * @param commitmentContractAddress Address of the commitment contract used
     * @param order The 1inch LOP order to fill
     * @param orderSignature The maker's signature for the order
     */
    function executeWithProof(
        uint[8] calldata proof,
        uint[8] calldata publicInputs,
        address[] calldata winners,
        address commitmentContractAddress,
        ILimitOrderProtocol.Order calldata order,
        bytes calldata orderSignature
    ) external {
        // 1. Verify the ZK proof
        _verifyProof(proof, publicInputs);
        
        // 2. Verify commitment contract and winners
        _verifyCommitments(publicInputs, winners, commitmentContractAddress);
        
        // 3. Execute the fill on 1inch LOP
        _executeFill(publicInputs, commitmentContractAddress, winners, order, orderSignature);
    }
    
    function _verifyProof(uint[8] calldata proof, uint[8] calldata publicInputs) internal {
        uint[2] memory pA = [proof[0], proof[1]];
        uint[2][2] memory pB = [[proof[2], proof[3]], [proof[4], proof[5]]];
        uint[2] memory pC = [proof[6], proof[7]];
        
        require(verifier.verifyProof(pA, pB, pC, publicInputs), "Invalid ZK proof");
    }
    
    function _verifyCommitments(
        uint[8] calldata publicInputs,
        address[] calldata winners,
        address commitmentContractAddress
    ) internal {
        require(factory.isValidCommitmentContract(commitmentContractAddress), "Invalid commitment contract");
        require(uint160(commitmentContractAddress) == publicInputs[7], "Commitment contract address mismatch");
        
        BidCommitment commitmentContract = BidCommitment(commitmentContractAddress);
        
        for (uint256 i = 0; i < winners.length && i < 4; i++) {
            if (winners[i] != address(0)) {
                bytes32 expectedCommitment = commitmentContract.getCommitment(winners[i]);
                require(expectedCommitment != bytes32(0), "Winner has no commitment");
                require(expectedCommitment == bytes32(publicInputs[i]), "Commitment mismatch for winner");
            }
        }
    }
    
    function _executeFill(
        uint[8] calldata publicInputs,
        address commitmentContractAddress,
        address[] calldata winners,
        ILimitOrderProtocol.Order calldata order,
        bytes calldata orderSignature
    ) internal {
        uint256 totalFill = publicInputs[4];
        uint256 weightedAvgPrice = publicInputs[5];
        
        emit ProofVerified(commitmentContractAddress, totalFill, weightedAvgPrice);
        
        require(totalFill > 0, "No fill amount");
        require(totalFill <= order.makingAmount, "Fill exceeds order amount");
        
        address receiver = order.receiver != address(0) ? order.receiver : order.maker;
        
        (, uint256 actualTaking) = lop.fillOrder(order, orderSignature, totalFill, 0, receiver);
        
        require(actualTaking > 0, "Fill failed");
        
        emit AuctionExecuted(commitmentContractAddress, winners, actualTaking, weightedAvgPrice);
    }
    
    /**
     * @dev Verifies a proof without executing (for testing)
     * @param proof The Groth16 proof components
     * @param publicInputs The public inputs to the ZK circuit
     * @return bool True if the proof is valid
     */
    function verifyProofOnly(
        uint[8] calldata proof,
        uint[8] calldata publicInputs
    ) external view returns (bool) {
        uint[2] memory pA = [proof[0], proof[1]];
        uint[2][2] memory pB = [[proof[2], proof[3]], [proof[4], proof[5]]];
        uint[2] memory pC = [proof[6], proof[7]];
        
        return verifier.verifyProof(pA, pB, pC, publicInputs);
    }
    
    /**
     * @dev Returns the expected public input format for documentation
     * @return string Description of public input format
     */
    function getPublicInputFormat() external pure returns (string memory) {
        return "publicInputs[0-3]: winner commitments, [4]: totalFill, [5]: weightedAvgPrice, [6]: makerAsk, [7]: commitmentContractAddress";
    }
} 
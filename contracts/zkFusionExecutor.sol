// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "./interfaces/ILimitOrderProtocol.sol";
import "./CommitmentFactory.sol";
import "./BidCommitment.sol";

// Fixed circuit size for zkFusion hackathon
// For production, deploy separate contracts for different N values
uint8 constant N_MAX_BIDS = 8;

// Groth16 Verifier interface (auto-generated by Circom)
interface IVerifier {
    function verifyProof(
        uint[2] memory _pA,
        uint[2][2] memory _pB,
        uint[2] memory _pC,
        uint[4] memory _pubSignals  // Updated: now expects 4 outputs (totalFill, weightedAvgPrice, numWinners, winnerBitmask)
    ) external view returns (bool);
}

/**
 * @title zkFusionExecutor
 * @dev Main contract for executing zkFusion auctions with ZK proof verification
 * @notice Updated for 1inch LOP v4 compatibility
 */
contract zkFusionExecutor {
    ILimitOrderProtocol public immutable lop;
    IVerifier public immutable verifier;
    CommitmentFactory public immutable factory;
    
    event ProofVerified(
        address indexed commitmentContract,
        uint256 totalFill,
        uint256 weightedAvgPrice
    );
    
    event AuctionExecuted(
        address indexed commitmentContract,
        bytes32 indexed orderHash,
        uint256 makingAmount,
        uint256 takingAmount,
        address[] winners
    );
    
    constructor(
        address _lop,
        address _verifier,
        address _factory
    ) {
        lop = ILimitOrderProtocol(_lop);
        verifier = IVerifier(_verifier);
        factory = CommitmentFactory(_factory);
    }
    
    // Helper functions to work with Address type (which is uint256 in 1inch)
    function _addressFromUint(Address addr) internal pure returns (address) {
        return address(uint160(Address.unwrap(addr)));
    }
    
    function _addressToUint(address addr) internal pure returns (Address) {
        return Address.wrap(uint256(uint160(addr)));
    }
    
    function _takerTraitsFromUint(uint256 value) internal pure returns (TakerTraits) {
        return TakerTraits.wrap(value);
    }
    
    /**
     * @dev Execute a zkFusion auction with ZK proof verification
     * @param proof The Groth16 proof (8 field elements: pA, pB, pC)
     * @param publicOutputs The public outputs from ZK circuit [totalFill, weightedAvgPrice, numWinners, winnerBitmask]
     * @param winnerBitmask 8-bit bitmask indicating which bidders won (bit i = 1 if bidder i won)
     * @param commitmentContractAddress Address of the commitment contract for this auction
     * @param order The 1inch Limit Order Protocol order to fill
     * @param orderSignature Signature for the order
     */
    function executeWithProof(
        uint[8] calldata proof,
        uint[4] calldata publicOutputs,
        uint8 winnerBitmask,
        address commitmentContractAddress,
        ILimitOrderProtocol.Order calldata order,
        bytes calldata orderSignature
    ) external {
        // 1. Verify the ZK proof
        _verifyProof(proof, publicOutputs);
        
        // 2. Verify commitment contract and winner bitmask
        _verifyCommitments(publicOutputs, winnerBitmask, commitmentContractAddress);
        
        // 3. Execute the fill on 1inch LOP
        _executeFill(publicOutputs, commitmentContractAddress, winnerBitmask, order, orderSignature);
    }
    
    function _verifyProof(uint[8] calldata proof, uint[4] calldata publicOutputs) internal {
        uint[2] memory pA = [proof[0], proof[1]];
        uint[2][2] memory pB = [[proof[2], proof[3]], [proof[4], proof[5]]];
        uint[2] memory pC = [proof[6], proof[7]];
        
        require(verifier.verifyProof(pA, pB, pC, publicOutputs), "Invalid ZK proof");
    }
    
    function _verifyCommitments(
        uint[4] calldata publicOutputs,
        uint8 winnerBitmask,
        address commitmentContractAddress
    ) internal {
        require(factory.isValidCommitmentContract(commitmentContractAddress), "Invalid commitment contract");
        
        // Extract values from public outputs
        // publicOutputs = [totalFill, weightedAvgPrice, numWinners, winnerBitmask]
        uint256 zkWinnerBitmask = publicOutputs[3];
        require(uint256(winnerBitmask) == zkWinnerBitmask, "Winner bitmask mismatch");
        
        // Note: We can't verify individual commitments from public outputs alone
        // The ZK circuit proves that revealed bids match their commitments privately
        // This verification would need to be done differently or moved to circuit
    }
    
    function _executeFill(
        uint[4] calldata publicOutputs,
        address commitmentContractAddress,
        uint8 winnerBitmask,
        ILimitOrderProtocol.Order calldata order,
        bytes calldata orderSignature
    ) internal {
        // Extract values from public outputs
        // publicOutputs = [totalFill, weightedAvgPrice, numWinners, winnerBitmask]
        uint256 totalFill = publicOutputs[0];
        uint256 weightedAvgPrice = publicOutputs[1];
        uint256 numWinners = publicOutputs[2];
        
        emit ProofVerified(commitmentContractAddress, totalFill, weightedAvgPrice);
        
        require(totalFill > 0, "No fill amount");
        require(totalFill <= order.makingAmount, "Fill exceeds order amount");
        
        // Convert winner bitmask to addresses for event emission
        address[] memory winnerAddresses = new address[](numWinners);
        uint256 winnerIndex = 0;
        
        BidCommitment commitmentContract = BidCommitment(commitmentContractAddress);
        for (uint8 i = 0; i < N_MAX_BIDS && winnerIndex < numWinners; i++) {
            if ((winnerBitmask >> i) & 1 == 1) {
                // This bidder won - get their address from commitment contract
                // Note: This requires the commitment contract to track bidder addresses
                winnerAddresses[winnerIndex] = commitmentContract.getBidder(i);
                winnerIndex++;
            }
        }
        
        // Execute the fill on 1inch LOP
        bytes32 r;
        bytes32 vs;
        assembly {
            r := mload(add(orderSignature, 0x20))
            vs := mload(add(orderSignature, 0x40))
        }
        
        TakerTraits takerTraits = _takerTraitsFromUint(0);
        lop.fillContractOrder(order, r, vs, totalFill, takerTraits);
        
        emit AuctionExecuted(
            commitmentContractAddress,
            winnerAddresses,
            totalFill,
            weightedAvgPrice,
            numWinners
        );
    }
    
    /**
     * @dev Helper function to create an order with proper Address types
     */
    function createOrder(
        uint256 salt,
        address maker,
        address receiver,
        address makerAsset,
        address takerAsset,
        uint256 makingAmount,
        uint256 takingAmount,
        uint256 makerTraits
    ) external pure returns (ILimitOrderProtocol.Order memory) {
        return ILimitOrderProtocol.Order({
            salt: salt,
            maker: _addressToUint(maker),
            receiver: _addressToUint(receiver),
            makerAsset: _addressToUint(makerAsset),
            takerAsset: _addressToUint(takerAsset),
            makingAmount: makingAmount,
            takingAmount: takingAmount,
            makerTraits: MakerTraits.wrap(makerTraits)
        });
    }
} 
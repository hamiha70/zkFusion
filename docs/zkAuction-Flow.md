# zkFusion Auction Flow - FINAL Architecture

**Version**: 2.0  
**Date**: July 31, 2025  
**Status**: FINAL

---

## üéØ **EXECUTIVE SUMMARY**

zkFusion implements a **verifiably fair Dutch auction system** that accelerates 1inch Fusion order execution. It uses off-chain computation with on-chain zero-knowledge proof verification to achieve speed, fairness, and integration with the 1inch Limit Order Protocol (LOP). This document defines the complete, final flow.

---

## üë• **ACTOR & COMPONENT DEFINITIONS**

### **Actors** 
*   **Maker**: The user who wants to sell an asset by creating a 1inch LOP order.
*   **Bidder / Resolver**: Off-chain entities who compete to fill the Maker's order.
*   **Auction Runner**: A specialized, off-chain entity (can be one of the Bidders) responsible for orchestrating the auction, generating the ZK proof, and submitting the final transaction.

### **On-Chain Components**
*   **`CommitmentFactory`**: A singleton contract that deploys and whitelists `BidCommitment` contracts, ensuring the Executor only interacts with authentic contracts.
*   **`BidCommitment`**: A per-auction contract holding a fixed array of 8 Poseidon hashes. It acts as the on-chain anchor of truth for the auction.
*   **`ZkFusionGetter`**: A 1inch LOP extension contract whose sole purpose is to verify the ZK proof within a `staticcall` by calling the Executor.
*   **`zkFusionExecutor`**: The main contract containing the business logic. It has a `view` function to verify a proof against the state of a `BidCommitment` contract and a state-changing function to execute the final settlement.
*   **`Verifier`**: The contract auto-generated by `snarkjs` that performs the final cryptographic verification of the ZK proof.

---

## üåä **COMPLETE AUCTION FLOW (FINAL)**

### **PHASE 1: AUCTION SETUP (On-Chain & Off-Chain)**

1.  **Maker Creates Intent (Off-Chain)**
    *   The Maker signs a standard 1inch LOP order specifying the asset to sell (`makerAsset`), the asset they want (`takerAsset`), and the maximum amount they are selling (`makingAmount`).

2.  **Auction Runner Deploys Contract (On-Chain)**
    *   The Auction Runner calls `CommitmentFactory.createCommitmentContract()`.
    *   This deploys a new, unique `BidCommitment` contract for this specific auction.

3.  **Auction Runner Initializes Contract (On-Chain & Off-Chain)**
    *   **Off-Chain**: The Runner computes the "null commitment" hash: `nullHash = Poseidon(0, 0, 0, address(newly_deployed_contract))`.
    *   **On-Chain**: The Runner calls `BidCommitment.initialize(nullHash)`. This populates all 8 slots in the commitment array with the `nullHash`, making the contract ready for bids.

### **PHASE 2: BIDDING (COMMIT PHASE)**

4.  **Bidders Prepare Bids (Off-Chain)**
    *   Bidders see the Maker's order and the address of the active `BidCommitment` contract.
    *   Each bidder decides on their `price` and `amount`.
    *   Each bidder computes their commitment hash: `commitment = Poseidon(price, amount, bidderAddress, commitmentContractAddress)`.

5.  **Bidders Commit On-Chain**
    *   Each bidder calls `BidCommitment.submitBid(slot, commitment)`, placing their hash into one of the 8 available slots. This is a public, on-chain transaction that costs gas.

### **PHASE 3: AUCTION RESOLUTION (REVEAL & PROOF)**

6.  **Bidders Reveal to Runner (Off-Chain)**
    *   Bidders send their full bid data (`price`, `amount`, `bidderAddress`) to the Auction Runner through a private, off-chain channel (e.g., a REST API).

7.  **Runner Validates and Runs Auction (Off-Chain)**
    *   The Runner verifies that the revealed data from each bidder matches the corresponding hash in the on-chain `BidCommitment` contract.
    *   The Runner executes the Dutch auction logic locally to determine the winning bids.
    *   From this result, the Runner creates the `originalWinnerBits` array (e.g., `[0, 1, 1, 0, ...]`).

8.  **Runner Generates ZK Proof (Off-Chain)**
    *   The Runner assembles all the necessary inputs for the ZK circuit:
        *   **Private Inputs**: The full list of all 8 bids (prices, amounts, addresses), plus sorting data.
        *   **Public Inputs**: The array of 8 commitments fetched from the `BidCommitment` contract, the maker's constraints, and the `originalWinnerBits` array it just computed.
    *   The Runner uses `snarkjs` to generate the Groth16 proof. **This will only succeed if the provided `originalWinnerBits` correctly matches the auction logic inside the circuit.**

### **PHASE 4: SETTLEMENT (ON-CHAIN VERIFICATION)**

9.  **Runner Triggers 1inch Settlement**
    *   The Runner calls `lop.fillOrder(...)` on the 1inch LOP contract.
    *   Crucially, the order includes an `extension` parameter pointing to our `ZkFusionGetter` contract.
    *   The `extension.takingAmountData` field contains the ZK proof and all the public inputs (`commitments`, `originalWinnerBits`, etc.).

10. **1inch LOP `staticcall`s our Getter**
    *   The 1inch contract sees the extension and makes a `staticcall` to our `ZkFusionGetter`. This is a read-only call.
    *   The Getter decodes the `takingAmountData` and calls `zkFusionExecutor.verifyAuctionProof(...)` with the proof and public inputs.

11. **Final On-Chain Verification**
    *   The `zkFusionExecutor` does the final checks inside the `staticcall`:
        1.  It asks the `CommitmentFactory` if the `commitmentContractAddress` is authentic.
        2.  It reads the `commitments` array from that on-chain contract.
        3.  It calls `Verifier.verifyProof()` with the proof and the full set of public inputs (including the commitments it just read).
    *   If the proof is valid, the `ZkFusionGetter` returns the `totalValue` to the 1inch LOP.

12. **Atomic Settlement**
    *   The 1inch LOP receives the valid amount, confirms all conditions are met, and executes the atomic swap. The Maker gets their `takerAsset`, and the winning Bidders' funds are used to fill the order.

---

## Feasibility Analysis: Gas & Time

Based on detailed analysis, this architecture is highly practical for a hackathon and beyond.

*   **Proving Time (Off-Chain)**: **8-15 seconds** on a standard developer laptop. Perfect for a live demo.
*   **On-Chain Verification Gas**: **~300,000 gas** on Arbitrum. This costs approximately **$0.12**, making the system economically viable.
*   **Security**: The system is secured by the cryptographic guarantees of ZK-SNARKs. The Auction Runner is trusted for *liveness* (generating the proof) but not for *correctness* (they cannot generate a fake proof or cheat the auction outcome).

This flow provides a fast, secure, and verifiably fair auction mechanism that seamlessly integrates with the existing 1inch LOP. 

## ZK Circuit Compilation Flow

### Circuit Architecture (N-Parameterized Design)

The `zkFusion` ZK circuit uses a **parameterized design pattern** for scalability:

- **Generic Template**: `circuits/zkDutchAuction.circom` defines `template zkDutchAuction(N)` 
- **Production Wrapper**: `circuits/zkDutchAuction8.circom` instantiates with `N=8` for 8 bidders
- **Test Wrapper**: `circuits/test/zkDutchAuction.circom` for testing with public input specifications

**Critical**: Always compile the **wrapper file** (`zkDutchAuction8.circom`), not the generic template.

### Compilation Requirements

**Current Circuit Complexity (N=8):**
- Non-linear constraints: 10,611
- Linear constraints: 3,700  
- **Total constraints: ~14,311**
- Public outputs: 3 (`totalFill`, `totalValue`, `numWinners`)
- Template instances: 82

**Powers of Tau Requirements:**
- Need: 2^15 (32,768) constraint support for ~14k constraints
- File size: Significant (generated pot15_0001.ptau for demo)

### Step-by-Step Compilation Process

```bash
# 1. Compile the N=8 wrapper (NOT the generic template)
circom circuits/zkDutchAuction8.circom --r1cs --wasm --sym -o ./dist -l node_modules

# 2. Generate Powers of Tau (for demo/testing)
npx snarkjs powersoftau new bn128 15 pot15_0000.ptau -v
npx snarkjs powersoftau contribute pot15_0000.ptau pot15_0001.ptau --name="Demo contribution" -v
npx snarkjs powersoftau prepare phase2 pot15_0001.ptau pot15_final.ptau -v

# 3. Generate proving key
npx snarkjs groth16 setup ./dist/zkDutchAuction8.r1cs pot15_final.ptau ./dist/zkDutchAuction8_0000.zkey

# 4. Generate Solidity verifier contract
npx snarkjs zkey export solidityverifier ./dist/zkDutchAuction8_0000.zkey ./contracts/Verifier.sol
```

### Common Compilation Errors & Solutions

**Error: "No main specified"**
- **Cause**: Compiling generic template instead of wrapper
- **Solution**: Use `circuits/zkDutchAuction8.circom`

**Error: "circomlib/circuits/... not found"**  
- **Cause**: Missing include paths
- **Solution**: Add `-l node_modules` flag

**Error: "Parse error on line 1"**
- **Cause**: Using deprecated npm circom vs. Rust circom
- **Solution**: Use globally installed `circom` binary, not `npx circom`

**Error: "ENOENT: pot12_final.ptau"**
- **Cause**: Wrong powers of tau file or insufficient constraint support
- **Solution**: Generate pot15+ for 14k+ constraints

### Verifier Contract Expectations

The generated `contracts/Verifier.sol` should have:
- **4 public inputs**: `uint[4] calldata _pubSignals` (updated from previous 3)
- Function: `verifyProof(uint[2] _pA, uint[2][2] _pB, uint[2] _pC, uint[4] _pubSignals)`
- Compatible with `zkFusionExecutor.verifyAuctionProof()` function

## Circuit Correctness Status

### ‚úÖ What We Know is Correct

**1. Circuit Compilation:**
- ‚úÖ Circuit compiles successfully (14,311 constraints)
- ‚úÖ Generates valid R1CS and WASM artifacts
- ‚úÖ Powers of Tau setup completed (2^15 constraint support)
- ‚úÖ Verifier contract generated with correct signature (`uint[3]` public outputs)

**2. Architecture Validation:**
- ‚úÖ **Final specification confirmed**: 3 outputs (`totalFill`, `totalValue`, `numWinners`)
- ‚úÖ **Public input security**: `originalWinnerBits` validated by internal `bitValidator` constraints
- ‚úÖ **Hash function**: 4-input Poseidon correctly implemented
- ‚úÖ **N-parameterized design**: Wrapper pattern working correctly

**3. Business Logic Testing:**
- ‚úÖ **Pure JavaScript auction simulation** extensively tested in `circuits/utils/auction-simulator.ts`
- ‚úÖ **Functional validation suite** with 686 lines of test cases
- ‚úÖ **Sorting algorithms** validated independently
- ‚úÖ **Dual constraint logic** (price + quantity) working correctly

### ‚ö†Ô∏è What Needs Verification

**1. Circuit-to-JavaScript Consistency:**
- ‚ùì **Critical Gap**: No end-to-end proof that circuit logic matches JavaScript simulation
- ‚ùì **Witness generation**: Need to verify circuit produces same outputs as `simulateAuction()`
- ‚ùì **Constraint satisfaction**: Need proof generation test with real data

**2. Integration Points:**
- ‚ùì **Hash compatibility**: Mock Poseidon vs. real Poseidon in circuit
- ‚ùì **Field element conversion**: JavaScript BigInt ‚Üî Circuit field elements
- ‚ùì **Address handling**: Ethereum addresses in circuit context

## JavaScript/TypeScript Utility Functions

### üéØ **Core Functions Available (GOOD NEWS!)**

The codebase already has the exact functions we need for the demo:

**Location**: `circuits/utils/auction-simulator.ts`
```typescript
// Main auction computation - matches circuit logic
simulateAuction(bids, constraints) ‚Üí AuctionResult {
  totalFill: bigint,
  totalValue: bigint, 
  numWinners: bigint,
  winners: Bid[],
  winnerBitmask: number
}

// Generate sorting arrays for circuit
generateSortingArrays(originalBids, sortedBids) ‚Üí {
  sortedPrices: bigint[],
  sortedAmounts: bigint[],
  sortedIndices: bigint[]
}

// Convert bitmask to array format
generateWinnerBits(winnerBitmask, N=8) ‚Üí number[]
```

**Location**: `circuits/utils/input-generator.ts`
```typescript
// Complete circuit input generation
generateCircuitInputs(bids, commitments, constraints) ‚Üí CircuitInputs

// Individual input formatters
formatBidsForCircuit(bids) ‚Üí FormattedBids
generateCommitmentHashes(bids, contractAddress) ‚Üí bigint[]
```

### üîß **What We Need for Demo Script**

**1. Refactor into Demo-Ready Module:**
```typescript
// New file: src/demo/auction-engine.ts
export class AuctionEngine {
  // Pure computation (no ZK)
  computeAuctionResults(bids, constraints): AuctionResult
  
  // ZK-ready inputs
  generateCircuitInputs(bids, commitments, constraints): CircuitInputs
  
  // Verification
  validateResults(circuitOutputs, expectedOutputs): boolean
}
```

**2. Integration Points Needed:**
- ‚úÖ **Business logic**: Already implemented and tested
- ‚ö†Ô∏è **Real Poseidon hashing**: Replace mock with `circomlibjs`
- ‚ö†Ô∏è **Witness generation**: Interface with compiled WASM
- ‚ö†Ô∏è **Proof generation**: Interface with snarkjs

### üìã **Recommended Next Steps**

1. **Create unified demo utility** (`src/demo/auction-engine.ts`)
2. **Replace mock Poseidon** with real implementation
3. **Add end-to-end circuit test** (JavaScript ‚Üí Circuit ‚Üí Verification)
4. **Integrate with 1inch LOP SDK** for order creation 
# zkFusion Auction Flow - FINAL Architecture

**Version**: 2.0  
**Date**: July 31, 2025  
**Status**: FINAL

---

## ðŸŽ¯ **EXECUTIVE SUMMARY**

zkFusion implements a **verifiably fair Dutch auction system** that accelerates 1inch Fusion order execution. It uses off-chain computation with on-chain zero-knowledge proof verification to achieve speed, fairness, and integration with the 1inch Limit Order Protocol (LOP). This document defines the complete, final flow.

---

## ðŸ‘¥ **ACTOR & COMPONENT DEFINITIONS**

### **Actors** 
*   **Maker**: The user who wants to sell an asset by creating a 1inch LOP order.
*   **Bidder / Resolver**: Off-chain entities who compete to fill the Maker's order.
*   **Auction Runner**: A specialized, off-chain entity (can be one of the Bidders) responsible for orchestrating the auction, generating the ZK proof, and submitting the final transaction.

### **On-Chain Components**
*   **`CommitmentFactory`**: A singleton contract that deploys and whitelists `BidCommitment` contracts, ensuring the Executor only interacts with authentic contracts.
*   **`BidCommitment`**: A per-auction contract holding a fixed array of 8 Poseidon hashes. It acts as the on-chain anchor of truth for the auction.
*   **`ZkFusionGetter`**: A 1inch LOP extension contract whose sole purpose is to verify the ZK proof within a `staticcall` by calling the Executor.
*   **`zkFusionExecutor`**: The main contract containing the business logic. It has a `view` function to verify a proof against the state of a `BidCommitment` contract and a state-changing function to execute the final settlement.
*   **`Verifier`**: The contract auto-generated by `snarkjs` that performs the final cryptographic verification of the ZK proof.

---

## ðŸŒŠ **COMPLETE AUCTION FLOW (FINAL)**

### **PHASE 1: AUCTION SETUP (On-Chain & Off-Chain)**

1.  **Maker Creates Intent (Off-Chain)**
    *   The Maker signs a standard 1inch LOP order specifying the asset to sell (`makerAsset`), the asset they want (`takerAsset`), and the maximum amount they are selling (`makingAmount`).

2.  **Auction Runner Deploys Contract (On-Chain)**
    *   The Auction Runner calls `CommitmentFactory.createCommitmentContract()`.
    *   This deploys a new, unique `BidCommitment` contract for this specific auction.

3.  **Auction Runner Initializes Contract (On-Chain & Off-Chain)**
    *   **Off-Chain**: The Runner computes the "null commitment" hash: `nullHash = Poseidon(0, 0, 0, address(newly_deployed_contract))`.
    *   **On-Chain**: The Runner calls `BidCommitment.initialize(nullHash)`. This populates all 8 slots in the commitment array with the `nullHash`, making the contract ready for bids.

### **PHASE 2: BIDDING (COMMIT PHASE)**

4.  **Bidders Prepare Bids (Off-Chain)**
    *   Bidders see the Maker's order and the address of the active `BidCommitment` contract.
    *   Each bidder decides on their `price` and `amount`.
    *   Each bidder computes their commitment hash: `commitment = Poseidon(price, amount, bidderAddress, commitmentContractAddress)`.

5.  **Bidders Commit On-Chain**
    *   Each bidder calls `BidCommitment.submitBid(slot, commitment)`, placing their hash into one of the 8 available slots. This is a public, on-chain transaction that costs gas.

### **PHASE 3: AUCTION RESOLUTION (REVEAL & PROOF)**

6.  **Bidders Reveal to Runner (Off-Chain)**
    *   Bidders send their full bid data (`price`, `amount`, `bidderAddress`) to the Auction Runner through a private, off-chain channel (e.g., a REST API).

7.  **Runner Validates and Runs Auction (Off-Chain)**
    *   The Runner verifies that the revealed data from each bidder matches the corresponding hash in the on-chain `BidCommitment` contract.
    *   The Runner executes the Dutch auction logic locally to determine the winning bids.
    *   From this result, the Runner creates the `originalWinnerBits` array (e.g., `[0, 1, 1, 0, ...]`).

8.  **Runner Generates ZK Proof (Off-Chain)**
    *   The Runner assembles all the necessary inputs for the ZK circuit:
        *   **Private Inputs**: The full list of all 8 bids (prices, amounts, addresses), plus sorting data.
        *   **Public Inputs**: The array of 8 commitments fetched from the `BidCommitment` contract, the maker's constraints, and the `originalWinnerBits` array it just computed.
    *   The Runner uses `snarkjs` to generate the Groth16 proof. **This will only succeed if the provided `originalWinnerBits` correctly matches the auction logic inside the circuit.**

### **PHASE 4: SETTLEMENT (ON-CHAIN VERIFICATION)**

9.  **Runner Triggers 1inch Settlement**
    *   The Runner calls `lop.fillOrder(...)` on the 1inch LOP contract.
    *   Crucially, the order includes an `extension` parameter pointing to our `ZkFusionGetter` contract.
    *   The `extension.takingAmountData` field contains the ZK proof and all the public inputs (`commitments`, `originalWinnerBits`, etc.).

10. **1inch LOP `staticcall`s our Getter**
    *   The 1inch contract sees the extension and makes a `staticcall` to our `ZkFusionGetter`. This is a read-only call.
    *   The Getter decodes the `takingAmountData` and calls `zkFusionExecutor.verifyAuctionProof(...)` with the proof and public inputs.

11. **Final On-Chain Verification**
    *   The `zkFusionExecutor` does the final checks inside the `staticcall`:
        1.  It asks the `CommitmentFactory` if the `commitmentContractAddress` is authentic.
        2.  It reads the `commitments` array from that on-chain contract.
        3.  It calls `Verifier.verifyProof()` with the proof and the full set of public inputs (including the commitments it just read).
    *   If the proof is valid, the `ZkFusionGetter` returns the `totalValue` to the 1inch LOP.

12. **Atomic Settlement**
    *   The 1inch LOP receives the valid amount, confirms all conditions are met, and executes the atomic swap. The Maker gets their `takerAsset`, and the winning Bidders' funds are used to fill the order.

---

## Feasibility Analysis: Gas & Time

Based on detailed analysis, this architecture is highly practical for a hackathon and beyond.

*   **Proving Time (Off-Chain)**: **8-15 seconds** on a standard developer laptop. Perfect for a live demo.
*   **On-Chain Verification Gas**: **~300,000 gas** on Arbitrum. This costs approximately **$0.12**, making the system economically viable.
*   **Security**: The system is secured by the cryptographic guarantees of ZK-SNARKs. The Auction Runner is trusted for *liveness* (generating the proof) but not for *correctness* (they cannot generate a fake proof or cheat the auction outcome).

This flow provides a fast, secure, and verifiably fair auction mechanism that seamlessly integrates with the existing 1inch LOP. 